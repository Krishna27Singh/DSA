A local class cannot access the local variables of the enclosing function
however it can access the static variables of the enclosing function and exteral variables/global variables and functions
A global class can access the global/static varibales! 

NESTED class
class A{
    class B{

    }
}

# class B cannot access members of class access
# scope of B is limited to A 
# if you want to create objects of class B we need to proceed the name of class A 
# A::B obj we can make object of B like this

EMPTY CLASS 
NO DATA MEMBERS NO MEMBER function
class class_Name{

};

ANONYMOUS CLASS 
# no name for the class
class {'

} obj1, obj2;
# we have to declare the objects just after the class declaration

COMPOSITION AND CONTAINERSHIP AND COMPLEX objects
class B{

};
class C{

};
class A{
    B objB;
    C objC;
};
# class A contains objects of class B and CLASS CLASS C 
# through object of class A we can call members and member function of class B and class C 
# composition is a relationship wherer one clas sown another class completely
# if the parent object is destroyed the child object is also destroyed

FRIEND FUNCTION 
# friend function can acces private, public or protected members of that class
# in some cases it cannot
# friend function does not have any object by default

class Rectangle{
float l, b;
public: 
    void Input();
    friend void area(Rectangle &);
};

void Rectangle :: Input(){
    cin>>l>>b;
}

void area(Rectangle &r){
    float area = r.l * r.b;
    cout<<area<<endl;
    return;
}

int main(){
    Rectangle r1; 
    r1.Input();
    area(r);
    return 0;
}
# not all the work which is done by member function should be done by the friend function becaause it violates the data hiding principal of cpp.
# friend function do not has a "this" pointer.
# if you want to work with the data members of two classes, there comes the need of friend function!
# friend function can be declared in either private or public.

class B {}; -> forward declaration so that it does not give error in class A 
class A{
int a;
friend void sum( A&, B& );
};

class B{
int b; 
public:
    friend void sum( A&, B&);
};

void sum( A& Aobj, B& Bobj){
    cout<< Aobj.a + Bobj.b <<endl;
}

int main(){
    A obj1;
    B obj2;
    obj1.Input();
    obj2.Input();
    sum(obj1, obj2);
    return 0;
}

ft& addFeetAndInches(ft& f, in& i){
    ft temp;
    temp.feet = f.feet + (i.inches)/12.0 ;
    return temp;
}

int main(){
    ft f1, f2;
    in i1;
    f1.input();
    f2 = addFeetAndInches(f1, i1);
    f2.display();
    return 0;
}

FRIEND CLASS
# friend function or friend class declaration can be done in either private or public!
class b{};
class a{
    friend class b;
};
class b{
# all member function will be friend of class A 
# class a can access public/private/protected members of class b 
# but b cannot access class a!     

friend class a;
# now the friendship and mutual and class b can also access the private/public/protected members of class a 

};

CONSTRUCTOR AND DESTRUCTOR
Properties of constructor function

CONSTUCTOR FUNCTON -> automatically executed when object of a class is made
# it does not have any return type
# not even void 
# consturctor function is not inherited to the child class
# a constructor function cannot be static, virtual and constant
# a static member function belonged to the class and it could not access the non static members of the class
# constructor function has to be declarated in the public. if declare in private then it does not give compiler error but it will not be executed! 
# It can be defined within or outside the class 
# a constructor function can also be overloaded 
# constructor function can also have default arguments 

TYPES OF CONSTRUCTOR FUNCTION 
1) DEFAULT CONSTRUCTOR (it does not have any arguments)
2) PARAMETESIZED CONSTRUCTOR (can have one or more parameters)
3) COPY CONSTRUCTOR (only one argument of the same object type in reference, initialize the data members from the data members of the argument object)
{
DUMMY CONSTRUCTOR -> default and copy constructor are automatically generated by the system! 
# it does not do anything 
# only allocates memory to the data members

DYNAMIC CONSTRUCTOR -> if the data member is pointer
# if we are allocating memory dynamically to some dynamic variables/pointers with the new keyword then it is called dynamic constructor. but it is not a major constructo type.

# if you are making your own constructor then system does not generate any constructor
# if you make copy construtor then default constructor will not be made by the system, you have to make both if you want both. 
}

class Rectangle{
float l, b; 
public:
    # EXAMPLE OF DEFAULT CONSTRUCTOR
    Rectangle(){
        cout<<"Enter length of rectangle: "<<endl;
        cin>>l;
        cout<<"Enter breadth of rectangle: "<<endl;
        cin>>b;
    }
    # EXAMPLE OF PARAMETESIZED CONSTRUCTOR
    Rectangle(float &len, float &bre){
        l = len;
        b = bre;
    }
    Rectanlge (float &side){
        l = side;
        b = side;
    }
    # EXAMPLE OF COPY CONSTRUCTOR
    Rectangle(Rectangle &r){ 
        l = r.l;
        b = r.b;
    }

    void Area(){
        cout<<"Area of rectangle is: "<<l*b<<endl;
    }
};

int main(){
    Rectangle r1, r2(4), r3(4, 5), r4(r3), r5 = r3;
    # implicit -> r5 -> implicit way of calling copy constructor
    # explicit -> r4 -> explicit way of calling copy constructor 
    # default constructor will be called for r1, if we have only made parametrsed or copy and not default then it would have gave an error!
    # Rectangle r1() -> error 
    # in copy constructor we pass object by reference only otherwise it will give infinite loop 
    # because if we pass by value then (Recangle r = r3) -> again copy constructor will be called and again (Rectangle r = r) is invoked and it becomes infinite loop!
    # If we pass by reference then simply the reference to that is done and no copy is created!

    r1.area(); -> 20
    r2.area(); -> 16
    r3.area(); -> 20
    r4.area(); -> 20
    r5.area(); -> 20
}

DESTRUCTOR FUNCTION
# same name as class name but provided by ~
# It is executed when the lifetime of object ends (object goes out of the scope)
# or when it is deleted explicitly with the help of delete keyword
# There can be atmost 1 destructor function for a class ( no destructor overloading and no parameters)
# It can be a virtual function
# it cannot be inherited like the constructor function

class Rectangle{
public:
    Rectangle(){
        cout<<"constructing object: "<<*this<<endl;
    }
    ~Rectangle(){
        cout<<"destroying object: "<<*this<<endl;
    }
};

int main(){
    Rectangle r1, r2;
    return 0;
}

output
constructing object r1
constructing object r2
destroying function r2
destroying object r1
#first object r2 will be be destroyed because it will go out of the scope first 

class Complex{
int real, imaginary;
Complex(){
    cout<<"Enter the real part:"<<endl;
    cin>>real;
    cout<<"Enter the imaginary part:"<<endl;
    cin>>imaginary;
}

friend void Sum(&Complex, &Complex);
void Display(){
    cout<<real<<" + i"<<imaginary<<endl;
}
};

void sum(&Complex, &Complex){
    a.real = a.real + b.real ;
    a.imaginary = a.imaginary + b.imaginary;
}

int main(){
    Complex a, b;
    Sum(a, b);
    a.Display();
}